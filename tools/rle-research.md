# Hypotheses (corpus-driven, TSV-indexed)

This file is based on the **full corpus of original `.PIC` files**, with each original compressed stream transformed into a normalized, comparable token breakdown in `research/rle_breakdown/*.tsv`.

Important framing: these originals are **already compressed** artifacts — outputs of an original content pipeline/encoder whose implementation details are unknown, and whose true input assets (raw sprites, intermediate formats, build-time padding rules, etc.) aren’t available here.

What we *can* treat as ground truth is the decoder behavior (CGA/EGA/HERC/TANDY) and the exact on-disk compressed byte streams those decoders consume; the TSVs are the index we use for most claims (so we can cite exact offsets/tails consistently), and we also cross-check against `EGA.DRV.lst` disassembly where relevant.

## Problem statement

We want to **recompress** original Wizardry VI `.PIC` files in a way that reproduces the **original compressed bytestreams byte-for-byte** (token boundaries and control bytes), not merely produce data that decompresses to the same pixels.

At the moment our compressor matches the original tokenization for almost all corpus files, but there’s a rare end-of-stream anomaly in **two** assets:
- `MON16.PIC` ends with a final short run token `RLE(1, 0xFF)` immediately before the `0x00` terminator.
- `MON51.PIC` ends with a final short run token `RLE(2, 0xFF)` immediately before the `0x00` terminator.

Short RLE (length 1–2) is legal under the decoder, but it’s almost never used in the corpus — so this document collects encoder-side hypotheses that could explain why the originals chose (or accidentally produced) these specific EOF tokens.

Legend:
- Each TSV row is a decompression token from the *original* compressed stream.
- `type` is `LITERAL` or `RLE`.
- `out_i` is the decompressed offset at which the token starts.
- `cmp_j` is the “logical compressed cursor” used by `tests/test_rle.py` (control byte + payload).

## What we already know about the encoder (so far)

We don’t have the original encoder implementation or its input assets, so “how the encoder works” here means what we can infer from (a) the **decoder semantics** (ground truth), and (b) the **compressed streams observed in the corpus**.

Decoder / format semantics (confirmed from `EGA.DRV.lst` and consistent across CGA/EGA/HERC/TANDY decoders):
- The stream is PackBits-like RLE with a single-byte control.
- `0x00` terminates the stream.
- `0x01..0x7F`: literal token of that length (control value = literal length), followed by that many bytes.
- `0x80..0xFF`: RLE token; output length is $-\text{control}$ in 8-bit two’s complement (so `0xFF → 1`, `0xFE → 2`, ..., `0x80 → 128`), followed by one byte to repeat.

Encoder behavior we can infer from corpus outputs:
- The encoder is *allowed* to emit short RLE (`len=1–2`) but almost never does; in this corpus it occurs only twice (EOF-only, value `0xFF`).
- Many streams end with a `LITERAL`, so there’s no simple “always end in RLE” rule.
- Many streams end with literals that themselves contain trailing `0xFF` bytes, so there’s no global “force `FF` tail into RLE” rule.

Cost intuition (why short RLE is “weird”):
- `RLE(1, X)` always costs **2 compressed bytes** (control + value). If that single byte can be appended to a neighboring literal, it would typically cost only **1 additional byte** (the payload), so emitting `RLE(1)` is usually strictly worse.
  - If it *can’t* be appended because the literal would exceed the 127-byte cap (or due to a page-boundary/padding constraint), then encoding that one byte as `LITERAL(1)` costs **2 bytes** as well — i.e. `RLE(1)` is still not better, just tied.
- `RLE(2, X)` also costs **2 bytes**, and if those two bytes can be appended to a neighboring literal it would typically cost **2 additional bytes** (payload only), so `RLE(2)` is also usually dominated unless the append is impossible.
- More generally, splitting a literal into `LITERAL(prefix)` + `RLE(k)` + `LITERAL(suffix)` has overhead (extra literal control byte for the second literal). That’s one reason a common heuristic is “minimum RLE length = 3” in the *general* (non-EOF) case.

Constraints (what we still *don’t* know):
- The encoder’s run/literal decision rule (minimum run length, tie-breaks, lookahead) isn’t recoverable from decoder semantics alone.
- The encoder may have had buffering (input/output chunking), post-processing passes, or structure-aware boundaries; we can only test such ideas indirectly via token-trace patterns.

## What we know from the corpus

- Short RLE (length 1–2) exists, but only **twice** in the entire corpus.
  - `MON16.PIC`: `RLE len=1 val=FF` very near the end.
  - `MON51.PIC`: `RLE len=2 val=FF` very near the end.

Evidence (scan across all TSVs):
- short-RLE tokens found: **2**
  - `MON16.PIC.tsv`: `out_i=10455 cmp_j=9033 type=RLE out_len=1 data_hex=FF`
  - `MON51.PIC.tsv`: `out_i=11478 cmp_j=9838 type=RLE out_len=2 data_hex=FFFF`

## Hypothesis table

| # | Hypothesis about original encoder | Prediction if true | Result vs evidence | Examples (TSV evidence / other evidence) |
|---:|---|---|---|---|
| 1 | **“Streams always end with an RLE before terminator.”** | Last non-empty token (`out_len>0`) is always `RLE`. | **False.** Many streams end with a `LITERAL`. | Counterexamples (last token is `LITERAL`): `MON48.PIC.tsv` last token `LITERAL out_len=11` (`out_i=21422 cmp_j=15666 tail=BF3FFF3FBFC3E1F3`); `MON07.PIC.tsv` last token `LITERAL out_len=14` (`out_i=3466 cmp_j=2394 tail=17A757E7479757D7`). (There are 18 such files total.) |
| 2 | **“Short RLE (len 1–2) is used generally.”** | Many files would contain `RLE` tokens with `out_len` 1 or 2. | **False.** Only two occurrences in the entire corpus, both value `0xFF`. | Evidence: only `MON16.PIC.tsv` has `RLE out_len=1`, and only `MON51.PIC.tsv` has `RLE out_len=2`. No other `.tsv` contains `RLE` with length 1 or 2. |
| 3 | **“Whenever the last bytes are `FF`/`FFFF`, the encoder forces them into RLE.”** | If a stream ends with literals containing trailing `FF` bytes, those should instead appear as a final `RLE` token in originals. | **False.** There are many files whose **last token is a LITERAL** and still ends with `FF` bytes. | Counterexample: `MON49.PIC.tsv` last token `LITERAL out_len=7` with tail `...01FFFF` (`out_i=14417 cmp_j=11159`). Counterexample: `MON31.PIC.tsv` last token `LITERAL out_len=6` tail `...03FFFF` (`out_i=19315 cmp_j=13698`). Counterexample: `MON35.PIC.tsv` last token `LITERAL out_len=6` tail `...CFFFFF` (`out_i=18482 cmp_j=14869`). |
| 4 | **“Short RLE is an end-of-stream quirk only.”** | If short RLE appears, it should be right at the end (as the last non-empty token), probably adjacent to the terminator, and likely with the same byte value. | **Consistent with evidence.** Both short RLE tokens are the **final non-empty** tokens in their streams, both value `0xFF`. | Evidence: `MON16.PIC.tsv` ends with `... LITERAL out_len=96 (tail ...1FF7); RLE out_len=1 data=FF` (final). `MON51.PIC.tsv` ends with `... LITERAL out_len=83 (tail ...6FEF); RLE out_len=2 data=FFFF` (final). |
| 5 | **“(Observed) Short RLE only appears with value `0xFF`.”** | If the encoder can emit short RLE for other values too, we should eventually find `RLE out_len=1` or `2` with a non-`FF` data byte in some file. | **Currently untestable beyond the observed corpus fact.** In this corpus, the only short-RLE tokens are both for `0xFF`, but we have *no* examples of short RLE with other values to confirm or refute the broader rule. | Evidence (corpus scan): the only short-RLE tokens are `MON16.PIC.tsv` `RLE(1,FF)` and `MON51.PIC.tsv` `RLE(2,FF)`. |
| 6 | **“Short RLE is triggered by seeing a longer run in a ‘read-ahead’ buffer (stale bytes), and mainly affects the final run.”** | We’d expect to see an RLE token after a literal that ends with `FF` (or near `FF` changes), and the short RLE length would not necessarily match the true run length in the output; it would show up at the very end. | **Plausible but unproven from the corpus traces alone.** TSVs show *that* short RLE is isolated at EOF, but they don’t expose the encoder’s lookahead. | Supporting pattern: both `MON16` and `MON51` have a large final literal whose tail contains `...FF...` and then a final short RLE of `FF`. Counterweight: many other files also have final literals ending in `FF` bytes but do *not* get short-RLE. |
| 7 | **“EOF run search reads past end of *input* buffer, effectively sampling stale bytes from previous input block.”** (e.g. 4K / 2K / 1K / 512B blocks) | The encoder’s run detector would compare `src[i]` vs `src[i+1]` (etc.) even when `i` is the final byte(s), so it may *think* the final `FF` continues (because stale bytes beyond EOF are also `FF`). This could produce a short final `RLE(1,FF)` or `RLE(2,FF)` in cases where the real data ends with one/two `FF`. | **Note on prior “negative sweeps”: earlier model implementations were not capable of emitting short EOF RLE at all (the modeled encoder used a hard “min-run>=3” policy everywhere), so “no short EOF RLE produced” was not meaningful evidence.** The overread mechanism by itself only changes the *measured* run length; to reproduce the observed anomaly we likely need an additional EOF-only rule/bug (threshold/scoring) or a post-pass that can choose `RLE(1..2,FF)` at the very end. | Supporting: `MON16` ends with `...` then final `RLE(1,FF)`; `MON51` ends with `...` then final `RLE(2,FF)`. Counterweight: many other files have last literals that end in `...FFFF` (e.g. `MON49`, `MON31`, `MON54`) yet do *not* end in short-RLE, so if this bug exists it may require a very specific alignment/content of the stale bytes. |
| 8 | **“EOF run search copies candidate bytes into a temporary RLE-candidate buffer, then reads past that buffer, effectively sampling the *previous* candidate’s tail.”** | If the encoder’s ‘count run length’ loop uses a staging buffer and over-reads it near EOF, the observed extra bytes would resemble data that was processed *just before* the last candidate. This could also make it *appear* that a 1–2 byte `FF` tail belongs to a longer `FF` run, leading to an RLE token even when a minimum run threshold would normally suppress it. | **Note on prior “negative sweeps”: earlier model implementations couldn’t emit short EOF RLE by construction (min-run>=3), so “no short EOF RLE produced” was not meaningful evidence.** To make (8) capable of matching the anomaly, the model needs an additional EOF-only behavior (e.g. emit `RLE(1..2,FF)` when the run detector crosses the threshold only because it consulted stale bytes) or an explicit post-pass rewrite. We’ve since added a research-only toggle to explore exactly that kind of EOF-specific behavior. | Same concrete cases are the only positives: `MON16` final token `RLE(1,FF)` and `MON51` final token `RLE(2,FF)`. Counterweight remains: numerous tails contain `FF` bytes without producing a final short RLE, so any such bug would still need a trigger condition (buffer size, alignment, previous-candidate contents). |
| 9 | **“`0xFF` control byte is a special opcode (not normal PackBits-style RLE-of-length-1).”** | If `0xFF` had a special meaning, we’d expect its appearance to correlate with special structure (e.g. end markers, escapes, mode switches) rather than acting like a normal RLE control that produces exactly 1 output byte. | **Strongly contradicted by the driver listing (`EGA.DRV.lst`).** In `sub_1C25`, the decompressor logic is PackBits-style: `0x00` terminates (`or al,al` / `jz`), `al<0x80` is literal (`rep movsb`), and `al>=0x80` is RLE with length `-al` (`neg al`, then `rep stosb` of the next byte). Under this, `0xFF` means `-0xFF = 1` and `0xFE` means `2` — i.e. short RLE is legal and *not* special. | Primary-source evidence: `EGA.DRV.lst` lines around `seg000:1C74..1C88` show `lodsb; or al,al; jz ...; test al,80h; jnz ...; ...` and in the RLE branch `neg al; mov cl,al; lodsb; rep stosb`. TSV examples remain consistent with this: `MON16.PIC.tsv` ends with `RLE out_len=1 data=FF` and `MON51.PIC.tsv` ends with `RLE out_len=2 data=FFFF`. |
| 10 | **“EOF literal flush bug: last 1–2 bytes fall out of the literal accumulator and get re-emitted as a short RLE.”** | Only appears at EOF; occurs when the final literal accumulator ends with `FF` bytes; the encoder outputs a final literal that is shorter by 1–2 bytes, followed by `RLE(1/2,FF)`. | **Plausible but not provable from token traces.** We can see the *result* pattern (final literal + short RLE) in the original compressed stream, but not whether it’s a bug versus an explicit heuristic. | Positive cases (original tokenization): `MON16.PIC.tsv` ends with `LITERAL out_len=96 ...` then `RLE out_len=1 data=FF`; `MON51.PIC.tsv` ends with `LITERAL out_len=83 ...` then `RLE out_len=2 data=FFFF`. Counterweight: many other files have final bytes `FF` but do not end with short RLE. |
| 11 | **“Heuristic: if the *final decompressed bytes* are exactly `FF` or `FFFF` (run length 1–2), prefer encoding them as short RLE.”** | Files whose final decompressed `FF` run length is exactly 1 or 2 would generally end with `RLE(1/2,FF)` even if short runs are otherwise avoided. | **False as a general rule.** TSV-derived reconstruction of the final decompressed bytes shows multiple files ending with 1–2 `FF` bytes, yet only `MON16`/`MON51` end with short-RLE tokens. This could still hold as a *conditional* rule (e.g. depends on alignment or previous token). | TSV-derived summary facts: final `FF` run len = 1 occurs in **5** files (`MON16`, `MON25`, `MON42`, `MON45`, `MON57`) but only `MON16` ends with `RLE(1,FF)`. Final `FF` run len = 2 occurs in **10** files (`MON02`, `MON08`, `MON09`, `MON11`, `MON31`, `MON35`, `MON37`, `MON49`, `MON51`, `MON54`) but only `MON51` ends with `RLE(2,FF)`. |
| 12 | **“Decompressed-space alignment rule: avoid crossing a 4K boundary at EOF, so split last 1–2 bytes into a short RLE.”** | The MON16/MON51 tail offsets should be unusually close to a 0x1000 boundary in decompressed space (last output end offset near `...000`/`...FFF`). | **Contradicted by TSV-derived alignment checks.** `MON16` ends at offset 10456 (mod 4096 = 2264) and `MON51` ends at 11480 (mod 4096 = 3288), which are not particularly close to a 4K boundary. Other files are much closer without exhibiting short-RLE. | Counterexamples by proximity: `MON04.PIC.tsv` ends at mod 4096 = 4088 (distance 8) but ends with a `LITERAL`; `MON13.PIC.tsv` also ends at mod 4096 = 4088 but ends with `RLE out_len=6` (not a short EOF RLE). |
| 13 | **“Control-byte / terminator interaction at EOF: encoder avoids certain final literal forms and falls back to RLE for the last 1–2 bytes.”** | Short RLE should correlate with a case where emitting the final literal would cause an extra token, an awkward length, or a problematic control byte (so EOF takes an alternate encode path). | **Plausible but not provable from token traces.** We can’t see the encoder’s internal literal buffering, so proving this would require instrumentation or a recovered encoder. | Supporting observation: both short-RLE cases appear literally as the final token before the terminator. Counterweight: other files have equally “normal” endings and do not trigger this. |
| 14 | **“Masked/word-compare bug near EOF: run detector compares with masking or wider units, so it misclassifies near-`FF` bytes as equal and emits a run.”** | Short RLE would disproportionately involve `0xFF` because it is invariant under many masks/bit operations, making it more likely for buggy comparisons to ‘extend’ an apparent `FF` run at EOF. | **Plausible but weakly supported.** The corpus fact “the only observed short-RLE value is `FF`” is compatible with this, but we lack any short-RLE examples for other bytes to evaluate comparator behavior. | Supporting: `MON16` and `MON51` short-RLE bytes are `FF`. Counterweight: many other tails contain dense `FF` bytes but still end as literals (e.g. `MON54` last token is a `LITERAL` tail `...FBFBFFFF`). |
| 15 | **“Pipeline pads decoded sprite-set length at EOF with `0xFF`, and that padding is (sometimes) encoded as a short `RLE(FF)` right before the terminator.”** | If an entry’s decoded bytes are expected to end on a specific boundary (most naturally: the end of the last *present* 32-byte block in the entry’s block stream), then a file that is short by 1–2 bytes would be padded with `0xFF` up to that expected length. **Motivation:** if the last block’s 32-byte payload is incomplete, the renderer would interpret whatever bytes happen to follow as remaining plane/row bytes and may show junk *inside that last block*. Padding the missing tail with `0xFF` is a safe default (transparent/no bits) and can be appended cheaply. A practical way to do this *without re-running the whole compressor* is a **post-pass** that appends `RLE(FF)` (len 1–2) immediately before the `0x00` terminator. | **Plausible; stronger and more concrete than the earlier wording.** We have (a) TSV evidence that only `MON16`/`MON51` append short `RLE(FF)` tokens directly at EOF, and (b) a corpus observation that padding bytes at EOF can exist outside the sprite data (notably `CREDITS.PIC` has extra trailing bytes that are not referenced by any entry). What we still *don’t* have is a mechanically proven rule that `MON16`/`MON51` were short relative to an entry/block boundary — but the “1–2 bytes from EOF, inside the last block” constraint makes “pad to complete the last 32-byte block” a very natural target. **Note:** we still do *not* rely on any post-block overread theory here; the risk is specifically “incomplete bytes inside the final block payload”, not reading past blocks or adding bytes after a completed block. | Supporting (TSVs): `MON16` ends with `RLE(1,FF)` and `MON51` ends with `RLE(2,FF)` as final non-empty tokens. Supporting (manual decoded-set check): `CREDITS.PIC` contains extra unreferenced trailing bytes, showing EOF padding can occur in the pipeline. Counterweight: many other monster files end with `FF` bytes inside literals, so the pad must be conditional (only when the stream is otherwise short). |
| 16 | **“Encoder is aware of internal sprite-collection structure and that influences token boundaries (including EOF behavior).”** | If the payload is a collection of sprites/frames/bitplanes, the encoder might restart literal buffers at frame boundaries, encode each plane/scanline independently, or apply special-case handling when finishing the last frame. That could lead to unusual EOF tokenization in just a few assets. | **Weaker given an additional constraint.** The short-RLE anomaly happens extremely close to EOF, but based on manual inspection of decoded sprite sets, the special-case appears to occur **inside the final block’s bytes** (a few bytes from the end, i.e. “middle of a block”), *not* at an obvious sprite/entry boundary. If that’s correct, it argues against a clean “structure boundary” explanation (frame/entry/scanline), and points more toward a low-level encoder edge case (EOF flush/overread/padding) that just happens to land inside the last block’s 32-byte payload. | Supporting: anomaly is extremely rare (2 files), consistent with an edge case. Counterweight (manual decoded-set check): the suspected location is “2–5 bytes from EOF inside the last block”, which doesn’t correlate with higher-level sprite-set structure, weakening structure-aware explanations. |
| 17 | **“Last literal flush bug specifically at the 0x7F (127) literal cap.”** | If the encoder emits literals in 127-byte chunks, a bug in the EOF flush could incorrectly split the final 1–2 bytes of an otherwise-literal run into a short `RLE(FF)`. We’d expect MON16/MON51’s final literal sizes (or internal buffer sizes) to be near a 127 boundary. | **Plausible but not provable from token traces.** We see the final tokenization pattern in the outputs, but not the encoder’s internal literal buffering thresholds or chunk-flush logic. | Evidence: `MON16` ends with `LITERAL out_len=96` then `RLE(1,FF)`; `MON51` ends with `LITERAL out_len=83` then `RLE(2,FF)`. Counterweight: without instrumentation of the original encoder, “127-boundary” is a guess. |
| 18 | **“Signed/unsigned underflow in ‘emit final literal length’ causes 1–2 bytes to be dropped then re-emitted as RLE.”** | A classic C bug could make the computed final literal length off by 1–2 near EOF (e.g. `len = end-start-1` or `int8` underflow). A cleanup path might then output the leftover bytes via the RLE path. This would be EOF-only and could produce exactly `RLE(1/2,FF)` if the leftover bytes are `FF`. | **Plausible but not provable from token traces.** Token traces are compatible with “final literal short by 1–2, then short RLE”, but can’t prove an arithmetic/typing bug. | Positives: Only two files show the EOF short-RLE pattern, consistent with a rare trigger condition. Counterweight: no evidence for non-`FF` leftovers. |
| 19 | **“EOF run-length detector uses 16-bit word compares and misbehaves on the last odd byte(s), strongly biasing toward `0xFF`.”** | If the encoder counts runs using `uint16_t` reads (or unaligned word compares), the final 1–2 bytes could be miscounted when the loop crosses EOF. If stale/high bytes tend to be `0xFF` (or are masked to `0xFF`), this could spuriously trigger a short `RLE(FF)` at EOF. | **Plausible but not provable from token traces.** Token traces show the symptom (EOF-only short-RLE, value `FF`) but not the run-detector implementation. | Supporting: the only observed short-RLE value is `0xFF`, which is consistent with “stale high byte is 0xFF” style bugs. Counterweight: we don’t see other short-RLE values to differentiate implementations. |
| 20 | **“End-of-loop finalization / invariant-maintenance bug (EOF flush path differs from steady-state).”** | The encoder processes input in a loop maintaining some invariant (e.g. “pending literal buffer” is empty at loop top, or “current run candidate” has been committed). In the normal path the invariant is repaired each iteration, but the EOF path either skips the final repair/flush step or calls it with different parameters. This would only affect the very end of the stream and could manifest as “last 1–2 bytes emitted via a different code path” → `RLE(1/2,FF)` right before terminator. | **Plausible; not directly testable from token traces.** The EOF-only nature is compatible, but the corpus traces don’t expose internal encoder invariants or state transitions. | Evidence: anomaly occurs only at EOF and only in 2 files. Counterweight: without an encoder implementation, this is a structural explanation that overlaps with several other EOF-only bug hypotheses (flush bug, underflow bug) and needs a more specific predicted signature to be confirmable. |
| 21 | **“Block-based buffering boundary effect (input and/or output is chunked), and MON16/MON51 hit a rare boundary case.”** | The encoder might consume input or emit output in fixed-size blocks (not necessarily large: 1,2,4,8,… bytes; or 128/256/512/1K/4K). When the final bytes land at a boundary, the encoder may flush a partially filled buffer and then handle the last 1–2 bytes via the RLE path (or via a padded block), producing `RLE(1/2,FF)` at EOF. A tell would be MON16/MON51 having EOF positions unusually close to some modulus, while other files are not. | **Unproven; currently weak evidence.** A simple 4K decompressed-space alignment check was contradicted (Hypothesis #12), but that doesn’t rule out other chunk sizes or chunking in *compressed* space or in internal encoder buffers. | Evidence: pattern is EOF-only and extremely rare, compatible with “rare alignment trigger”. Counterweight: we haven’t yet found a convincing modulus (in `out_i` or `cmp_j`) that uniquely singles out MON16/MON51 versus other files; needs targeted scans across moduli and across both `out_i` and `cmp_j`. |
| 22 | **“Two-level / two-pass encoder: first pass emits rough tokens, then a post-pass ‘glues’ adjacent chunks and may rewrite the tail.”** | If there’s a later pass that merges adjacent literal chunks, merges adjacent RLEs, or normalizes chunk boundaries, it might have special-case logic at EOF (e.g. ensuring a terminator, ensuring a final flush) that can accidentally (or intentionally) turn the last 1–2 bytes into a short `RLE(FF)` token. This resembles Hypothesis #15’s “post-pass append before terminator,” but generalized: the post-pass could also rewrite the final literal length and then emit leftover `FF` via RLE. | **Plausible; consistent with the observed ‘EOF-only rewrite’ shape, but not provable from traces alone.** | Evidence: the resulting structure (large final literal + tiny final RLE + terminator) is exactly the kind of thing a post-pass could generate. Counterweight: many other files also have “awkward” endings (trailing `FF` bytes) but do *not* receive this rewrite, so any post-pass would still need a narrow trigger condition. |
| 23 | **“EOF scoring / threshold bug: encoder uses a different cost model at end-of-stream (or flush path), accidentally allowing short RLE.”** | If the encoder’s decision rule is “emit RLE only if it beats (or ties) literal encoding,” it likely uses a byte-cost calculation. But that calculation may differ at EOF (no future tokens), or the EOF flush path may omit/forget a term in the cost model. <br><br>In particular: <br>- For a run that is *in the middle* of a literal, replacing `k` bytes with `RLE(k)` splits the literal, so you pay **an extra literal control byte** for the second literal. For `k=1` or `k=2` this makes the substitution typically cost **+1 byte net** (you spend 3 bytes: RLE ctrl+value + second literal ctrl) while saving only 1–2 literal payload bytes. <br>- At EOF, there is **no second literal**, so that extra control byte disappears. A buggy/simplified EOF scorer might therefore see `RLE(1)` / `RLE(2)` as “not worse” than keeping bytes in the final literal, and allow it. <br><br>This would naturally yield “short RLE appears only as the final token” and only in rare shapes where the EOF flush code takes a different branch. | **Plausible and matches the ‘EOF-only’ location, but needs a discriminating signature.** A pure “EOF scorer differs” rule would also tend to rewrite many other files whose last bytes are `FF`/`FFFF` (and many are appendable), which we do *not* observe — so the hypothesis likely requires an additional gate (alignment, literal-cap boundary, page/padding interaction, or a bug triggered only for certain tail states). | Supporting: both anomalies are the final token and have short length (exactly where an EOF-only scorer/flush path would act). Counterweight: many other files end with `...FF`/`...FFFF` inside the final literal without a short-RLE rewrite, so EOF-only scoring can’t be the only condition. |

## Concrete tail snippets (for quick reference)

These are the *last* non-empty tokens (from TSV tails):

- `MON16.PIC.tsv`:
  - `LITERAL out_len=96 out_i=10359 cmp_j=8936 tail=FFFF71A7F8E71FF7`
  - `RLE out_len=1 out_i=10455 cmp_j=9033 data=FF`

- `MON51.PIC.tsv`:
  - `LITERAL out_len=83 out_i=11395 cmp_j=9754 tail=FFFFDFBF1FDF6FEF`
  - `RLE out_len=2 out_i=11478 cmp_j=9838 data=FFFF`

- Counterexample `MON54.PIC.tsv` (contains multiple `RLE FFF...` segments, but ends with a `LITERAL` that itself ends in many `FF` bytes):
  - last token `LITERAL out_len=8 out_i=27345 cmp_j=22752 tail=E3E3B3F3FBFBFFFF`
